### 数字类型

ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。

在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 <code>64 位字节来储存一个浮点数</code>

### 十进制 转 二进制

在 JS 内部所有的计算都是以二进制方式计算的。 所以运算 0.1+0.2 时要先把 0.1 和 0.2 从十进制转成二进制。

0.1 转化成二进制的算法：

- 0.1\*2=0.2======取出整数部分 0
- 0.2\*2=0.4======取出整数部分 0
- 0.4\*2=0.8======取出整数部分 0
- 0.8\*2=1.6======取出整数部分 1
- 0.6\*2=1.2======取出整数部分 1
  接下来会无限循环
- 0.2\*2=0.4======取出整数部分 0
- 0.4\*2=0.8======取出整数部分 0
- 0.8\*2=1.6======取出整数部分 1
- 0.6\*2=1.2======取出整数部分 1

所以 0.1 转化成二进制是：0.0001 1001 1001 1001......

0.2 转化成二进制的算法：

- 0.2\*2=0.4======取出整数部分 0
- 0.4\*2=0.8======取出整数部分 0
- 0.8\*2=1.6======取出整数部分 1
- 0.6\*2=1.2======取出整数部分 1
  接下来会无限循环
- 0.2\*2=0.4======取出整数部分 0
- 0.4\*2=0.8======取出整数部分 0
- 0.8\*2=1.6======取出整数部分 1
- 0.6\*2=1.2======取出整数部分 1

所以 0.2 转化成二进制是：0.0011 0011 0011 0011......

这里要注意 0.1 和 0. 2 转成的二进制是无穷的。另外在现代浏览器中是用浮点数形式的二进制来存储二进制，所以还要把上面所转化的<code>二进制转成浮点数形式的二进制</code>

### 二进制转成浮点数形式的二进制

双精度浮点数用 1 位表示符号位，11 位表示指数位，52 位表示小数位，如下图所示
![浮点数](../../.vitepress/public/assets/basic/2.png)

- 符号位：正数为 0，负数为 1
- 指数位：阶数+偏移量。阶数是：2^(e-1)^-1，e 为阶码的位数；偏移量是把小数点移动到整数位只有 11 时移动的位数。正数表示向左移，负数表示向右移
- 小数位：即二进制小数点后面的数

接下来把 0.1 转成的二进制 0.0001 1001 1001 1001...... 转成浮点数形式的二进制。

先要把小数点移动到整数位只有 1，要向右移动 4 位，故偏移量为 −4，通过指位数的计算公式 2^(11-1)^-1-4 = 1019，把 1019 转成二进制为 1111111011，不够 11 位要补零，最终得出指位数为 01111111011；

小数位为 100110011001......，因为小数位只能保留 52 位，第 53 位为 1 故进 1。
转换结果如下图所示：
![浮点数](../../.vitepress/public/assets/basic/3.png)

### 浮点数相加

先把阶码调整为相同

0.1 是 1.1001100110011…… _ 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110..._ 2^-3，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… \* 2^-3

接下来是尾数计算:

```js
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
————————————————————————————————————————————————————————
 10.0110011001100110011001100110011001100110011001100111
```

我们得到结果为 10.0110011001100110011001100110011001100110011001100111 \* 2^-3

将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) \* 2^-2

括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成

1.0011001100110011001100110011001100110011001100110100 \* 2^-2

本来还有一个溢出判断，因为这里不涉及，就不讲了。

所以最终的结果存成 64 位就是

0 01111111101 0011001100110011001100110011001100110011001100110100

将它转换为 10 进制数就得到 0.30000000000000004440892098500626

因为<code>两次存储时的精度丢失加上一次运算时的精度丢失</code>，最终导致了 0.1 + 0.2 !== 0.3

参数：https://github.com/mqyqingfeng/Blog/issues/155

## 面试

问：0.1+0.2 等于 0.3 吗？ 为什么不等于

答：不等于。因为 JS 是用 64 来保存 浮点数。1 位存符号位，11 位存指数位，剩下 52 位存小数位。而 0.1 和 0.2 的二进制是 无限循环的。所以 0.1、0.2 转成浮点数的二进制时，会对 52 位后的二进制进行舍去(53 位为 1，进 1；为 0 舍弃)。这是第一次精度丢失。0.1 和 0.2 浮点数二进制相加导致 溢出一个位。要进行舍弃。这是第二次精度丢失。由于以上两种<code>精度丢失</code>，所以 0.1+0.2 不等于 0.3

问：“0.1+0.2 不等于 0.3 会引起那些 BUG？

答：

- 引起统计页面展示错乱的 BUG，展示多个小数点
- 还有 300.01 优惠 300 元后，支付金额不足 0.01 元等类似的 BUG

问：怎么解决 0.1+0.2 不等于 0.3 这个问题? 请封装一个方式来解决精度问题

答：
<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围. 如果误差能够小于 Number.EPSILON，我们就可以认为结果是可靠的

```js
function equal(left, right) {
  return Math.abs(left - right) < Number.EPSILON;
}
// equal(0.1-0.2, 0.1)
// false
// equal(0.1-0.2, -0.1)
// true
```
